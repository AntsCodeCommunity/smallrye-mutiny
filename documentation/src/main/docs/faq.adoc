== How Do I do x?

=== How do I transform items?

To transform items synchronously use the `apply` operators:

[source,java,indent=0]
----
include::../../../src/test/java/snippets/HowToTransformTest.java[tags=sync]
----

You can also transform items asynchronously using the `produceUni` / `produceCompletionStage` operators:

[source,java,indent=0]
----
include::../../../src/test/java/snippets/HowToTransformTest.java[tags=async]
----

If you need to generate a sequence of items use, `producePublisher`:

[source,java,indent=0]
----
include::../../../src/test/java/snippets/HowToTransformTest.java[tags=multi]
----

=== How do I filter/select items?

On `Multi`, you may need to filter / select items.
To achieve this, there is a set of methods available in `multi.transform()`:

[source,java,indent=0]
----
include::../../../src/test/java/snippets/HowToFilterTest.java[tags=filter]

include::../../../src/test/java/snippets/HowToFilterTest.java[tags=take]

include::../../../src/test/java/snippets/HowToFilterTest.java[tags=skip]

----

You can also drop distinct items or drop repetitions:

[source,java,indent=0]
----
include::../../../src/test/java/snippets/HowToFilterTest.java[tags=distinct]

include::../../../src/test/java/snippets/HowToFilterTest.java[tags=repetition]
----

=== Where are my map, flatMap and concatMap methods?

If you are a seasoned reactive developer, you may miss the infamous `map`, `flatMap`, `concatMap` methods.
Mutiny also proposes there methods using the most-used variants of them.

[source,java,indent=0]
----
include::../../../src/test/java/snippets/FlatMapTest.java[tags=code]
----

=== How do I merge, concatenate or combine Multis?

You can create instances of `Multi` by concatenating, merging, or combining `Multis` and `Publishers`:

[source,java,indent=0]
----
include::../../../src/test/java/snippets/MergeTest.java[tags=code]
----

=== How can I collect / accumulate results?

You can collect the items from a `Multi` using the method proposed by `collectItems()`:

[source,java,indent=0]
----
include::../../../src/test/java/snippets/CollectTest.java[tags=code]
----

You can also accumulate results using the `scan` method:

[source,java,indent=0]
----
include::../../../src/test/java/snippets/CollectTest.java[tags=acc]
----

=== How do I chain asynchronous calls?

To chain asynchronous calls, use the `onItem().produceUni` or `onItem().produceCompletionStage`:

[source, java, indent=0]
----
include::../../../src/test/java/snippets/HowToChainAsyncTest.java[tags=code]
----

=== How do I recover from failure?

Failure are inherent to software.
So you need handle them.
By default, they flow in the stream until they reach the final subscriber.
But at any stage you can process the failure and transform or recover from it.

The following snippet shows how you can recover from a failure on a `Uni`:

[source, java, indent=0]
----
include::../../../src/test/java/snippets/UniFailureTest.java[tags=code]
----

`Multis` have the same API letting you recovering from failure easily:

[source, java, indent=0]
----
include::../../../src/test/java/snippets/MultiFailureTest.java[tags=code]
----

Note that with `Multi`, a failure cancels the subscription, meaning you will not receive any more items.
The `retry` operator let you re-subscribe and continue the reception.

=== How do I handle `null`?

`null` is only accepted in the `Uni` type.
`uni.onItem().ifNull()` lets you decide what you want to do when the received item is `null`:

[source, java, indent=0]
----
include::../../../src/test/java/snippets/UniNullTest.java[tags=code]
----

=== How do I handle timeout?

`Uni` are often used to represent asynchronous operation, like a HTTP call.
So, it's not rare to need to add a timeout on this kind of operation, and recover if the timeout occurs.

This can be done using `Uni.ifNoItem()`:

[source, java, indent=0]
----
include::../../../src/test/java/snippets/TimeoutTest.java[tags=code]
----

On timeout, you can:

* fail
* recover with a specific item
* continue with another alternative `Uni`

=== How do I control the threads?

Except indicated otherwise, the next processor is invoked on the thread emitting the event from upstream.
You can switch to another thread using the `emitOn` operator.
The `emitOn` operator let you switch thread used to dispatch (upstream to downstream) events, so items, failure and completion.

[source, java, indent=0]
----
include::../../../src/test/java/snippets/EmitOnTest.java[tags=code]
----

=== How do I interact with CompletionStages?

`CompletionStage` and `CompletableFuture` are classes provided by Java to represent asynchronous actions.
However, there are not lazy, and do not follow a _subscription_ patterns.

Mutiny let you create `Uni` and `Multi` from instances from these classes.
Also, `Uni` offers a way to retrieve the item or the failure as a `CompletableFuture`.

[source, java, indent=0]
----
include::../../../src/test/java/snippets/CompletionStageTest.java[tags=code]
----

=== How do I interact with RX Java 2?

Mutiny allows converting Rx Java 2 types to/from Uni and Multi instances.
To enable this feature, add the following dependency to your `CLASSPATH`:

[source,xml,subs=attributes+]
----
<dependency>
    <groupId>io.smallrye.reactive</groupId>
    <artifactId>mutiny-rxjava</artifactId>
    <version>{version}</version>
</dependency>
----

Then, you would need to import:

[source, java]
====
import io.smallrye.mutiny.converters.multi.MultiRxConverters;
import io.smallrye.mutiny.converters.uni.UniRxConverters;
====

To create a `Uni` from RxJava 2 objects, use the following methods:

[source, java, indent=0]
----
include::../../../src/test/java/snippets/RxJavaTest.java[tags=uni-create]
----

When converting a `Completable` or an empty `Maybe` to a `Uni`, the `Uni` receives a `null` item.
Use `onItem().ifNull()` to handle this case.

Note that, when converting an `Observable` or a `Flowable` to a `Uni`, only the first element is requested.
Once received, the underlying subscription is cancelled.

Also note that you can create a `Uni` from a Reactive Streams `Publisher` using `Uni.createFrom().publisher(...)`.

To create Rx Java 2 types from a `Uni`, use the following methods:

[source, java, indent=0]
----
include::../../../src/test/java/snippets/RxJavaTest.java[tags=uni-export]
----

Because `Uni` can emit `null`, the default converter produces a `Single<Optional<T>>`.
You can retrieve a `Single<T>` and fail instead using `toSingle().failOnNull()`.

To create a `Multi` from RxJava 2 objects, use the following methods:

[source, java, indent=0]
----
include::../../../src/test/java/snippets/RxJavaTest.java[tags=multi-create]
----

As for `Uni`, you can create a `Multi` from a Reactive Streams `Publisher` using `Multi.createFrom().publisher(...)`.

You can also create RxJava 2 objects from a `Multi`:

[source, java, indent=0]
----
include::../../../src/test/java/snippets/RxJavaTest.java[tags=multi-export]
----

=== How do I interact with Reactor?

Mutiny allows converting Rx Java 2 types to/from Uni and Multi instances.
To enable this feature, add the following dependency to your `CLASSPATH`:

[source,xml,subs=attributes+]
----
<dependency>
    <groupId>io.smallrye.reactive</groupId>
    <artifactId>mutiny-reactor</artifactId>
    <version>{version}</version>
</dependency>
----

Then, you would need to import:

[source, java]
====
import io.smallrye.mutiny.converters.multi.MultiReactorConverters;
import io.smallrye.mutiny.converters.uni.UniReactorConverters;
====

To create a `Uni` from Reactor objects, use the following methods:

[source, java, indent=0]
----
include::../../../src/test/java/snippets/ReactorTest.java[tags=uni-create]
----

To create Reactor `Flux` and `Mono` instances from a `Uni`, use the following methods:

[source, java, indent=0]
----
include::../../../src/test/java/snippets/ReactorTest.java[tags=uni-export]
----

To create a `Multi` from Reactor objects, use the following methods:

[source, java, indent=0]
----
include::../../../src/test/java/snippets/ReactorTest.java[tags=multi-create]
----

You can also create Reactor objects from a `Multi`:

[source, java, indent=0]
----
include::../../../src/test/java/snippets/ReactorTest.java[tags=multi-export]
----

=== How do I control the back-pressure?

// TODO

=== How do wrap blocking calls?

// TODO

=== Using an Unicast Processor

// TODO

=== Where do I find the JavaDoc

The JavaDoc is published https://smallrye.io/smallrye-mutiny/apidocs/[there].
